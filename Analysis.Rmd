---
title: "Analysis"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)
```

# Libraries and imports
```{r}
library(tidyverse)
library(foreign)
library(NbClust)
library(fpc)
library(GGally)
set.seed(44)

# import the stats data
stats.df <- read_csv(
  "Inputs/Seasons_Stats.csv",
  col_types = cols(
    `3P` = col_double(),
    `3P%` = col_double(),
    `3PA` = col_double(),
    `3PAr` = col_double(),
    `AST%` = col_double(),
    BLK = col_double(),
    `BLK%` = col_double(),
    BPM = col_double(),
    DBPM = col_double(),
    DRB = col_double(),
    `DRB%` = col_double(),
    GS = col_double(),
    MP = col_double(),
    OBPM = col_double(),
    ORB = col_double(),
    `ORB%` = col_double(),
    PER = col_double(),
    STL = col_double(),
    `STL%` = col_double(),
    `TOV%` = col_double(),
    TRB = col_double(),
    `TRB%` = col_double(),
    `USG%` = col_double(),
    VORP = col_double(),
    `WS/48` = col_double(),
    blanl = col_double()
  )
)

# import the salaries data
salaries.df <- read_csv("Inputs/team_salaries_2016_2017.csv")

# clean up column names
names(stats.df)[6] <- "Team"
names(salaries.df)[1] <- "Team"
```


# Data cleanup
Why did we decide on these columns?

```{r}
# set the columns to keep
cols.to.keep <- c("Player", "Pos", "Age", "Team", "G", "MP", "FG", "FGA", "3P", "3PA", "2P", "2PA", "FT", "FTA", "TRB", "AST", "STL", "BLK", "PTS")

# filter out the columns and join with the salaries data
NBA.df <- stats.df %>% 
  filter(Year == 2017) %>% 
  select(cols.to.keep) %>% 
  left_join(y = salaries.df, by = "Team")
```

# EDA

```{r EDA}
# set the columns to explore
cols.to.keep <- cols.to.keep[!cols.to.keep %in% c("Player", "Pos", "Age", "Team")]

# range of the data
diff(apply(NBA.df[, cols.to.keep], MARGIN = 2, FUN = range))

# biavariate plot
ggpairs(data = NBA.df, columns = cols.to.keep)

# bivariate plot of log values
NBA.df %>% 
  select(cols.to.keep) %>% 
  mutate_all(log) %>% 
  ggpairs()
```

## Standardize and take the log of the data
Log transform may not be neccessary
```{r}
NBA.stdz <- NBA.df

# add some noise to remove 0s which will avoid -Inf after log transformation
NBA.stdz[, cols.to.keep] <- apply(NBA.stdz[, cols.to.keep], MARGIN = 2, jitter, amount = 0.001)

# apply log and scale
NBA.stdz[, cols.to.keep] <- log(NBA.stdz[, cols.to.keep])
NBA.stdz[, cols.to.keep] <- scale(NBA.stdz[, cols.to.keep])

# remove NaNs from the cols.to.keep columns only then join back to original
# data using a new index column
NBA.stdz <- NBA.stdz %>% 
  mutate(Index = row_number()) %>% 
  select(c(cols.to.keep, "Index")) %>% 
  na.omit() %>% 
  left_join(y = mutate(NBA.stdz[, c("Player", "Pos", "Age", "Team")],
                       Index = row_number()),
            by = "Index") %>% 
  select(-Index)

ggpairs(data = NBA.stdz, columns = cols.to.keep)
```

## Principle Component Analysis
```{r PCA}
# principle component analysis
NBA.pc <- princomp(NBA.stdz[, cols.to.keep], cor = T)

summary(NBA.pc)
NBA.pc$loadings
```


# Clustering
```{r}
NbClust(data = NBA.stdz[, cols.to.keep], method = 'centroid', index = 'ch')
km.clusts <- NbClust(data = NBA.stdz[, cols.to.keep], method = 'kmeans', index = 'ch')


plot(x = NBA.pc$scores[,'Comp.1'],
     y = NBA.pc$scores[,'Comp.2'],
     col = km.clusts$Best.partition)
```



